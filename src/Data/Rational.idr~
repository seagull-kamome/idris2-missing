module Data.Rational

import Data.So

%default total

export
record Rational where
  constructor MkRational
  num : Integer
  den : Integer

export numerator : Rational -> Integer
numerator x = x.num
export denominator : Rational -> Integer
denominator x = x.den

public export
Eq Rational where
  x == y = x.num == y.num && x.den == y.den

export infinity : Rational
infinity = MkRational 1 0

export notANumber : Rational
notANumber = MkRational 0 0


gcd : (Eq a, Num a, Abs a, Integral a) => a -> a -> a
gcd x y = go (abs x) (abs y)
  where go : a -> a -> a
        go x' y' = if y' == 0 then 0 else assert_total $ go y' (x' `mod` y')



export reduce : (num:Integer) -> (den:Integer) -> {auto _:So (den > 0)} -> Rational
reduce x y = let d = gcd x y in MkRational (x `div` d) (y `div` d)

infixr 9 %:

(%:) : (num:Integer) -> (den:Integer) -> {auto _:So (den /= 0)} -> Rational
(%:) num den with (den > 0)
 
-- = if den > 0 then reduce num den else ?
--  (%:) num den | Right _ = reduce (negate num) (negate den)

